# 요구사항 확인
## A. 소프트웨어 개발방법론
---
### A-1. 소프트웨어 생명주기 모델
---
A-1-1. 소프트웨어 생명주기 ( SDLC; Software Development Life Cycle )
 - 시스템의 요구분석부터 유지보수까지 전 공정을 체계화한 절차

A-1-2. 소프트웨어 생명주기 모델 프로세스
 - 요구사항 분석 -> 설계 -> 구현 -> 테스트 -> 유지보수
 - 요구사항 분석 : 기능 / 비기능 요구사항
 - 설계 : 시스템 구조 / 프로그램 / 사용자 인터페이스 설계
 - 구현 : 인터페이스 / 자료 구조 개발 / 오류 처리
 - 테스트 : 단위 / 통합 / 시스템 / 인수 테스트
 - 유지보수 : 예방, 완전, 교정, 적응 유지보수

A-1-2. 소프트웨어 생명주기 모델 종류
 - 폭포수 모델 : 개발 시 각 단계를 확실히 마무리한 뒤 넘어가는 모델 / 단계별 산출물이 명확 / 요구사항 변경이 어려움
 - 프로토타이핑 모델 : 발주자나 개발자 모두에게 공동의 참조 모델을 제공 / 프로토타입의 구현 단계의 구현 골격
 - 나선형 모델 : 시스템 개발 시 위험을 최소화하기 위해 점진적으로 완벽한 시스템으로 개발해 나가는 모델 / 계획 및 정의 -> 위험 분석 -> 개발 -> 고객 평가
 - 반복적 모델 : 구축대상을 나누어 병렬적으로 개발 후 통합하거나, 반복적으로 개발하여 점증 완성 시키는 SDLC 모델

![소프트웨어 생명주기 모델 비교](https://t1.daumcdn.net/cfile/tistory/9911C44B5BE9B1242E)


---
### A-2. 소프트웨어 개발방법론
---
 - 소프트웨어 개발 전 과정에 지속적으로 적용할 수 있는 방법, 절차, 기법

A-2-1. 소프트웨어 개방방법론 종류
 - 구조적 방법론 ( Structured Development ) : 전체 시스템을 기능에 따라 나누어 개발하고, 이를 통합하는 분할과 정복 접근 방식의 방법론 / 하향식 방법론
 - 정보공학 방법론 ( Information Engineering Development ) : 정보시스템 개발에 필요한 관리 절차와 작업 기법을 체계화한 방법론 / 개발주기를 이용해 대형 프로젝트를 수행하는 체계적인 방법론
 - 객체지향 방법론 ( Object-Oriented Development ) : ‘객체’라는 기본 단위로 시스템을 분석 및 설계하는 방법론 / 객체, 클래스, 메시지를 사용
 - 컴포넌트 기반 방법론 ( CBD: Component Based Development ) : 소프트웨어를 구성하는 컴포넌트를 조립해서 하나의 새로운 응용 프로그램을 작성하는 방법론 / 개발 기간 단축으로 인한 생산성 향상 / 확장성이 좋으며 소프트웨어 재사용이 가능
 - 애자일 방법론 ( Agile Development ) : 절차보다는 사람이 중심이 되어 변화에 유연하고 신속하게 적응하면서 효율적으로 시스템을 개발할 수 있는 신속 적응 경량 개발방법론

A-2-2. 애자일 방법론
A-2-2-1. 개념
 - 개발 기간이 짧고 신속하며, 폭포수 모형에 대비되는 방법론으로 개발과 함께 즉시 피드백을 받아서 유동적으로 개발할 수 있음

A-2-2-2. 유형
A-2-2-2-1. XP ( eXtreme Programming )
 - 가치 : 용기, 단순성, 의사소통, 피드백, 존중
 - 기본원리
 - 짝 프로그래밍
 - 공동 코드 소유 : 시스템에 있는 코드는 누구든지 언제라도 수정 가능하다는 원리
 - 지속적인 통합
 - 계획 세우기 : 고객이 요구하는 비즈니스 가치 정의 등
 - 작은 릴리즈 : 작은 시스템을 만들고 짧은 단위로 업데이트
 - 메타포어 : 공통적인 이름 체계와 시스템 서술서를 통해 고객과 개발자 간의 의사소통을 원활하게 한다는 원리
 - 간단한 디자인
 - 테스트기반 개발
 - 리팩토링
 - 40시간 작업
 - 고객 상주
 - 코드 표준

A-2-2-2-2. 스크럼 ( SCRUM )
 - 백로그 : 제품과 프로젝트에 대한 요구사항
 - 스프린트 : 2~4주의 짧은 개발 기간으로 반복적 수행으로 개발품질 향상
 - 스크럼 미팅 : 데일리 미팅
 - 스크럼 마스터 : 프로젝트 리더, 스크럼 수행 시 문제를 인지 및 해결하는 사람
 - 스프린트 회고 : 스프린트 주기를 되돌아보며 정해놓은 규칙 준수 여부 개선점 등을 확인 및 기록
 - 번 다운 차트 : 남아 있는 백로그 대비 시간을 그래픽적으로 표현한 차트

A-2-2-2-3. 린 ( FLEAN )
 - JUIT, 칸반 보드 사용
 - 원칙 : 낭비제거, 품질 내재화, 지식 창출, 늦은 확정, 빠른 인도, 사람 존중, 전체 최적화

A-2-2-2-4. 애자일과 전통 방법론 비교

![애자일과 전통적 방법론 비교](https://media.vlpt.us/images/kjh03160/post/256bd6d1-2d95-4e4a-8c44-669cbf96948b/image.png)


---
### A-3. 비용산정, 일정관리 모형
---
 - 소프트웨어 규모파악을 통한 투입자원, 소요시간을 파악하여 실행 가능한 계획을 수립하기 위해 비용을 산정하는 방식

A-3-1. 비용산정 모형 분류
 - 하향식 산정방법 : 전문가에게 비용 산정 의뢰 혹은 여러 전문가와 조정자를 통해 산정 / 종류 : 전문가 판단, 델파이 기법
 - 상향식 산정방법 : 세부적인 요구사항과 기능에 따라 필요한 비용을 계산하는 방식 / 종류 : 코드 라인 수( Loc ), Man Month, COCOMO 모형, 푸트남( putnam ) 모형, 기능점수( FP; function point ) 모형
참고 : 델파이 기법 ( 전문가의 경험적 지식을 통한 문제 해결 및 미래예측을 위한 기법 / 전문가 합의법 )

A-3-2. 종류
A-3-2-1. LoC 모형
 - 소프트웨어 각 기능의 원시 코드 라인 수의 낙관치, 중간치, 비관치를 측정하여 예측치를 구하고 이를 이용하여 비용을 산정하는 방식
 - 예측치 = ( 낙관치 + 중간치 + 비관치 ) / 6

A-3-2-2. Man Month 모형
 - 한 사람이 1개월 동안 할 수 있는 일의 양을 기준으로 프로젝트 비용을 산정하는 방식

A-3-2-3. COCOMO 모형
 - 보헴이 제안한 모형으로 프로그램 규모에 따라 비용을 산정하는 방식
 - 유형
 - 조직형 (= 기본형, 단순형) : 5만 라인 이하의 소프트웨어 개발하는 유형
 - 반 분리형 : 30만 라인 이하 소프트웨어 개발하는 유형
 - 임베디드형 : 30만 라인 이상의 소프트웨어 개발하는 유형

A-3-2-4. 푸트남 ( Putnam ) 모형
 - 소프트웨어 개발주기의 단계별로 욕할 인력의 분포를 가정하는 방식
 - 생명주기 예측 모형이라고 함

A-3-2-5. FP 모형
 - 요구 기능을 증가시키는 인자별로 가중치를 부여하고, 요인별로 가중치를 부여하고 요인별 가중치를 합산하여 총 기능의 점수를 계산하여 비용을 산정하는 방식
 - 기능점수 = 총 기능점수 X [0.65 + (0.1 X 총 영향도)]
 - 경험을 바탕으로 단순, 보통, 복잡한 정도에 따라 가중치 부여

A-3-3. 일정관리 모델 개념
 - 프로젝트가 일정 기한 내에 적절하게 완료될 수 있도록 관리하는 모델

A-3-4. 종류
 - 주 공정법 ( CPM; Critical Path Method ) : 여러 작업의 수행 순서가 얽혀 있는 프로젝트의 일정을 계산하는 기법 / 모든 자원 제약사항을 배제한 상태로 프로젝트의 시작과 끝을 나타내는 노드와 노드 간을 연결을 통해 공정을 계산하기 위한 액티비티 표기법
 - PERT ( Program Evaluation and Review Technique ) : 비관치, 중간치, 낙관치의 3점 추정방식을 통해 일정을 관리하는 기법
 - 중요 연쇄 프로젝트 관리 ( CCPM; Critical Chain Project Management ) : 주 공정 연쇄법으로 자원제약사항을 고려하여 일정을 작성하는 기법

참고 : CPM 일정 계산 예시 아래 사진을 참고

![CPM 일정 계산 예시](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FtCBkg%2FbtqYN0WoIhQ%2FJvTUPoFIvDsHOKLYKqmh1k%2Fimg.png)


---
## B. 현행 시스템 분석
---
### B-1. 현행 시스템 파악
---
B-1-1. 현행 시스템 파악 개념
 - 현행 시스템이 어떤 하위 시스템으로 구성되어 있고, 제공 기능 및 연계 정보는 무엇이며, 어떤 기술 요소를 사용하는지를 파악하는 활동
 - 사용하고 있는 SW / HW , 네트워크 구성 등을 파악하는 활동

B-1-2. 현행 시스템 파악 절차
 - 구성/기능/인터페이스 파악 -> 아키텍처 및 소프트웨어 구성 파악 -> HW 및 네트워크 구성 파악
B-1-2-1. 현행 시스템 구성/기능 및 인터페이스 파악
 - 현행 시스템 구성 현황 파악 : 조직의 주요 업무를 처리하는 기간 업무와 이를 지원하는 지원 업무로 구분하여 파악 / 정보시스템들의 명칭, 주요 기능들을 명시, 정보시스템의 현황 파악이 가능하도록 함
 - 기능 현황 파악 : 단위 업무 시스템이 현재 제공하고 있는 기능 파악 / 단위 업무 시스템 기능들을 주요 기능과 하부 기능으로 구분하여 계층 형으로 표시
 - 인터페이스 현황 파악 : 단위 업무 시스템이 다른 시스템과 주고받는 데이터의 종류, 데이터 형식, 프로토콜, 연계유형, 주기 파악 / 데이터 형식, 통신규약, 연계유형을 표시

B-1-2-2. 현행 시스템 아키텍처 및 소프트웨어 구성 파악
 - 현행 시스템 아키텍처 구성 파악 : 기간 업무를 수행하기 위하여 계층별로 어떠한 기술 요소들을 사용하고 있는지 최상위 수준에서 파악 / 가장 핵심이 되는 기간 업무 처리 시스템을 기준으로 파악
 - 소프트웨어 구성 파악 : 서버의 위치, 운용 서버의 주요 사양과 수량, 이중화 구현 여부를 파악
 - 네트워크 구성 파악 : 어떤 네트워크 장비를 사용하여 어떻게 구성되어 있는지 파악

B-1-3. 소프트웨어 아키텍처
 - 여러 가지 소프트웨어 구성요소와 그 구성요소가 가진 특정 중에서 외부에 드러나는 특성, 그리고 구성요소 간의 관계를 표현하는 시스템의 구조나 구조체

B-1-3-1. 소프트웨어 아키텍처 프레임워크 구성요소
 - 아키텍처 명세서 : 아키텍처를 기록하기 위한 산출물들 / 개별 뷰, 뷰 개괄 문서, 인터페이스 명세 등이 있음
 - 이해관계자
 - 관심사
 -- 사용자 : 기본적인 기능, 신뢰성, 보안, 사용성 등의 품질
 -- 유지보수자 입장 : 유지보수의 용이성
 -- 개발자 입장 : 적은 비용과 인력으로 개발
 - 관점 : 개별 뷰를 개발할 때 토대가 되는 패턴이나 양식
 - 뷰 : 서로 관련 있는 관심사들의 집합이라는 관점에서 전체 시스템을 표현
 - 근거 : 회의 결과, 보고 결과, 아키텍처 결정 근거
 - 목표 : 시스템의 목적, 사용, 운영 방법
 - 환경
 - 시스템

B-1-3-2. 소프트웨어 아키텍처 4+1 뷰
 - 유스케이스 뷰 : 도출하고 설계하며 다른 뷰를 검증하는 데 사용되는 뷰 / 사용자, 설계자, 개발자, 테스트 관점
 - 논리 뷰 : 시스템의 기능적인 요구사항이 어떻게 제공되는지 설명해주는 뷰 / 설계자, 개발자 관점
 - 프로세스 뷰 : 비기능적인 속성으로서 자원의 효율적인 사용, 병행 실행 비동기, 이벤트 처리 등을 표현한 뷰 / 개발자, 시스템 통합자 관점
 - 구현 뷰 : 개발 환경 안에서 정적인 소프트웨어 모듈의 구성을 보여주는 뷰 / 컴포넌트 구조와 의존성을 보여주고 컴포넌트에 관한 부가적인 정보 정의
 - 배포 뷰 : 컴포넌트가 물리적인 아키텍처에 어떻게 배치되는가를 매핑해서 보여주는 뷰

B-1-3-3. 소프트웨어 아키텍처 패턴
 - 소프트웨어 아키텍처에서 일반적으로 발생하는 문제점들에 대한 일반화되고 재사용 가능한 솔루션
 - 개발에 대한 시행착오를 줄여 개발 시간을 단축하고, 높은 품질의 소프트웨어 생산기 가능하며, 이미 검증된 구조이기 때문에 안정성이 높음
 - 유형
 - 계층화 : 각 하위 모듈들은 특정한 수준의 추상화를 제공, 다음 상위 계층에 서비스 제공, 마주 보는 두 개의 계층 사이에만 상호작용이 이루어짐
 - 클라이언트-서버 : 하나의 서버와 다수의 클라이언트로 구성된 패턴, 클라이언트를 통해 서버에 서비스 요청 -> 서버가 클라이언트에게 서비스 제공, 서버는 항상 요청을 대기
 - 파이프-필터 : 데이터 스트림을 생성하고 처리하는 시스템에서 사용 가능한 패턴, 재사용성이 좋고, 추가가 쉬워 확장이 용이
 - 브로커 : 분리된 컴포넌트들로 이루어진 분산 시스템에서 사용되고, 이 컴포넌트들은 원격 서비스 실행을 통해 상호작용이 가능한 패턴, 컴포넌트 간의 통신을 조정하는 역할 수행
 - MVC : 모델; 핵심 기능과 데이터 보관 / 뷰; 사용자에게 정보 표시 / 컨트롤러; 사용자로부터 요청을 입력받아 처리

B-1-3-4. 소프트웨어 아키텍처 비용 평가 모델
 - 아키텍처 접근법이 품질 속성에 미치는 영향을 판단하고 아키텍처의 적합성을 평가하는 모델
 - 종류
 - SAAM ( Software Architecture Analysis Method ) : 변경 용이성과 기능성에 집중, 평가가 용이하여 경험이 없는 조직에서도 활용 가능한 비용 평가 모델
 - ATAM ( Architecture Trade-off analysis Method ) : 아키텍처 품질 속성을 만족시키는지 판단 및 품질 속성들의 이해 상충관계까지 평가하는 모델
 - CBAM ( Cost Benefit Analysis Method ) : ATAM 바탕의 시스템 아키텍처 분석 중심으로 경제적 의사결정에 대한 요구를 충족하는 비용 평가 모델
 - ADR ( Active Design Review ) : 소프트웨어 아키텍처 구성요소 간 응집도를 평가하는 모델
 - ARID ( Active Reviews for Intermediate Designs ) : 특정 부분에 대한 품질요소에 집중하는 비용 평가 모델

B-1-4. 디자인패턴
 - 소프트웨어 설계에서 공통으로 발생하는 문제에 대해 자주 쓰이는 설계 방법을 정리한 패턴
B-1-4-1. 다자인 패턴 유형
 - 목적
 -- 생성 : 객체 인스턴스 생성에 관여, 클래스 정의와 객체 생성 방식을 구조화, 캡슐화를 수행하는 패턴
 -- 구조 : 더 큰 구조 형성 목적으로 클래스나 객체의 조합을 다루는 패턴
 -- 행위 : 클래스나 객체들이 상호작용하는 방법과 역할 분담을 다루는 패턴
 - 범위
 -- 클래스 : 클래스 간 관련성( 상속 관계를 다루는 패턴 ), 컴파일 타임에 정적으로 결정
 -- 객체 : 객체 간 관련성을 다루는 패턴, 런타임에 동적으로 결정

B-1-4-2. 디자인 패턴 종류
B-1-4-2-1. 생성 패턴
 - builder : 복잡한 인스턴스를 조립하여 만드는 구조, 생성과 표기를 분리해서 복잡한 객체를 생성
 - prototype : 일반적인 원형을 만들어 놓고, 복사한 후 필요한 부분만 수정하여 사용하는 패턴, 기존 객체를 복제함으로써 객체를 생성
 - Factory : 상위 클래스에서 객체를 생성하는 인터페이스를 정의하고, 하위 클래스에서 인스턴스를 생성하도록 하는 방식, 생성할 객체의 클래스를 국한하지 않고 객체를 생성
 - Abstract Factory : 구체적인 클래스에 의존하지 않고 서로 연관되거나 의존적인 객체들의 조합을 만드는 인터페이스를 제공하는 패턴, 동일한 주제의 다른 팩토리를 묶음
 - singleton : 전역 변수를 사용하지 않고 객체를 하나만 생성하도록 하며, 생성된 객체를 어디에서든지 참조할 수 있도록 하는 패턴, 한 클래스에 한 객체만 존재하도록 제한

B-1-4-2-2. 구조 패턴
 - Bridge : 기능의 클래스 계층과 구현의 클래스 계층을 연결하고, 구현부에서 추상 계층을 분리하여 추상화된 부분과 실제 구분 부분을 독립적으로 확장할 수 있는 패턴, 구현뿐만 아니라 추상화된 부분까지 변경해야 하는 경우 활용
 - Decorator : 기존에 구현되어 있는 클래스에 필요한 기능을 추가해 나가는 설계 패턴, 객체의 결합을 통해 기능을 동적으로 유연하게 확장
 - Facade : 복잡한 시스템에 대해 단순한 인터페이스를 제공함으로써 사용자와 시스템 간 혹은 여타 시스템과의 결합도를 낮추어 시스템 구조에 대한 파악을 쉽게 하는 패턴, 통합된 인터페이스 제공
 - Flyweight : 다수의 객체로 생성될 경우 모두가 갖는 본질적인 요소를 클래스 화하여 공유함으로써 메모리 절약, 경량화를 목적으로 하는 패턴, 여러 개의 ‘가상 인터페이스’를 제공하여 메모리 절감
 - Proxy : 실체 객체에 대한 접근 이전에 필요한 행동을 취할 수 있게 만들며, 이 점을 이용해서 미리 할당하지 않아도 상관없는 것들을 실제 이용할 때 할당하게 하여 메모리 절약, 실체 객체를 드러나지 않게 정보은닉의 역할도 수행하는 패턴, 특정 객체로의 접근을 제어하기 위한 용도로 사용
 - Composite : 객체들의 관계를 트리 구조로 구성하여 부분-전체 계층을 표현하는 패턴, 복합 객체와 단일 객체를 동일하게 취급
 - Adapter : 기존에 생성된 클래스를 재사용할 수 있도록 중간에서 맞춰주는 역할을 하는 인터페이스를 만드는 패턴, 인터페이스가 호환되지 않는 클래스들을 함께 이용할 수 있도록 타 클래스의 인터페이스를 기존 인터페이스에 덧씌움

B-1-4-2-3. 행위 패턴
 - Mediator : 중간에 중재자를 두어, 중재자에게 모든 것을 요구하며 통신의 빈도수를 줄여 객체지향의 목표를 달성하게 해주는 패턴
 - Interpreter : 언어의 다양한 해석, 구체적으로 구문을 나누고 그 분리된 구문의 해석을 맡는 클래스를 각각 작성하여 여러 형태의 언어 구문을 해석할 수 있게 만드는 패턴, 문법 자체를 캡슐화하여 사용
 - Iterator : 컬렉션 구현 방법을 노출시키지 않으면서 집합체에 들어있는 모든 항목에 접근할 방법을 제공하는 패턴, 내부구조를 노출하지 않고, 복잡 객체의 원소를 순차적으로 접근 가능하게 해주는 패턴
 - Template Method : 상위 작업의 구조를 바꾸지 않으면서 서브 클래스로 작업의 일부분을 수행
 - Observer : 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체들에 연락이 가고 자동으로 내용이 갱신되는 방법으로 일대 다의 의존성을 가지며 상호작용하는 객체 사이에서는 가능하면 느슨하게 결합하는 패턴, 객체의 사애 변화에 따라 다른 객체의 상태도 연동, 일대다 의존
 - State : 객체의 상태에 따라 행위 내용을 변경, 변경 시 원시 코드의 수정을 최소화할 수 있고 유지보수의 편의성도 갖는 패턴
 - Visitor : 각 클래스 데이터 구조로부터 처리 기능을 분리하여 별도의 클래스를 만들어 놓고 해당 클래스의 메서드가 각 클래스를 돌아다니며 특정 작업을 수행하도록 만드는 패턴, 특정 구조를 이루는 복합 객체의 원소 특성에 따라 동작을 수행할 수 있도록 지원하는 행위
 - Command : 실행될 기능을 캡슐화함으로써 주어진 여러 기능을 실행할 수 있는 재사용성이 높은 클래스를 설계하는 패턴, 하나의 추상 클래스에 메서드를 만들어 각 명령이 들어오면 그에 맞는 서브 클래스가 선택되어 실행되는 특징을 갖는 패턴, 요구사항을 객체로 캡슐화
 - Strategy : 행위를 클래스로 캡슐화해 동적으로 행위를 자유롭게 바꿀 수 있게 해주는 패턴, 행위 객체를 클래스로 캡슐화해 동적으로 행위를 자유롭게 변환
 - Memento : 객체를 이전 상태로 복구시켜야 하는 경우, ‘작업취소(Undo)’ 기능을 개발할 때 사용하는 패턴
 - Chain of Responsibility : 한 요청을 2개 이상의 객체에서 처리

B-1-5. 현행 시스템 분석서 작성 및 검토
B-1-5-1. 자료 수집
 - 정보시스템 구성/기능 및 인터페이스 자료 수집팀
 - 현행 시스템 아키텍처 및 소프트웨어 자료 수집팀
 - 하드웨어 및 네트워크 자료 수집팀

B-1-5-2. 수집 자료 분석
 - 수집된 정보 취합/정제, 중복되거나 유효하지 않은 정보 삭제
 - 불명확한 부분은 체크한 후 분석 및 설계 단계를 통해 구체적으로 조사
 - 현행 시스템의 이슈 및 문제점 파악

B-1-5-3. 산출물 작성
 - 정보시스템 구성 현황
 - 정보시스템 기능 구성도
 - 인터페이스 현황
 - 현행 시스템 아키텍처 구성도
 - 소프트웨어 / 하드웨어 / 네트워크 구성도

---
### B-2. 개발 기술 환경 정의
---
B-2-1. 개발 기술 환경 현행 시스템 분석
B-2-1-1. OS 현행 시스템 분석
 - 운영체제 ( OS ) : 사용자와 컴퓨터 하드웨어 간의 인터페이스를 담당하는 프로그램

B-2-1-1-1. OS 현행 시스템 분석 시 고려사항
 - 품질 측면 : 신뢰도, 성능
 - 지원 측면 : 기술 지원, 주변 기기, 구축 비용

B-2-1-2. OS 종류 및 특징
 - PC
 -- windows : 유지 / 관리 비용 장점
 -- UNIX : 대용량 처리, 안정성 높은 엔터프라이즈급 서버
 -- Linux : 중/대규모 서버 대상, 높은 보안성
 - mobile
 -- Android : 리눅스 OS 위에서 구동 / 사용자 인터페이스(UI), 표준 응용 프로그래 등을 포함하고 있는 리눅스 모바일 운영체제
 -- iOS : 높은 보안성 / 고성능 제공

B-2-1-2. 네트워크 현행 시스템 분석
 - 네트워크는 컴퓨터 장치들의 노드 간 연결(데이터 링크)을 사용하여 서로에게 데이터를 교환할 수 있도록 하는 기술
B-2-1-2-1. OSI 7계층

![OSI 7계층](http://wiki.hash.kr/images/7/71/OSI_7_%EA%B3%84%EC%B8%B5.jpg)


B-2-1-2-2. 관련 용어
 - 백본망(Backbone Network) : 다양한 네트워크를 상호 연결하는 컴퓨터 네트워크의 일부, 각기 다른 LAN이나 부분망 간에 정보를 교환하기 위한 경로를 제공하는 망
 - 라우터(Router) : 3계층 데이터 패킷을 발신지에서 목적지까지 전달하기 위해 최적의 경로를 지정, 경로를 ᄄᆞ라 데이터 패킷을 다음 장치로 전달하는 네트워크 장비
 - 스위치(Switch) : 2계층 장비, 동일 네트워크 내에서 출발지에 들어온 데이터 프레임을 목적지 MAC 주소 기반으로 빠르게 전달하는 네트워크 장비
 - 게이트웨이(Gateway) : 컴퓨터 네트워크에서 서로 다른 통신망, 프로토콜을 사용하는 네트워크 간의 통신을 가능하게 하는 네트워크 장비
 - 방화벽(Firewall) : 외부로부터 불법 침입과 내부의 불법 정보 유출을 방지, 내/외부 네트워크의 상호간 영향을 차단하기 위한 보안 장비

B-2-1-3. DBMS(Database Management System) 현행 시스템 분석
 - DB라는 데이터의 집합을 만들고, 저장 및 관리할 수 있는 기능들을 제공하는 응용 프로그램
B-2-1-3-1. DBMS의 기능
 - 중복 제어 / 접근 통제 / 인터페이스 제공 / 관계 표현 / 샤딩/파티셔닝 / 무결성 제약조건 / 백업 및 회복
 - 샤딩/파티셔닝 : 구조 최적화를 위해 작은 단위로 나누는 기능 제공

B-2-1-3-2. DBMS 현행 시스템 분석 시 고려사항
 - 성능 측면 : 가용성, 성능, 상호 호환성
 - 지원 측면 : 기술 지원, 구축 비용

B-2-1-3. 미들웨어 현행 시스템 분석
 - 분산 컴퓨팅 환경에서 응용 프로그램과 프로그램이 운영되는 환경 간에 원만한 통신이 어우러질 수 있도록 제어해주는 소프트웨어 / WAS가 대표적
B-2-1-3-1. WAS( Web Application Server )
 - 서버계층에서 애플리케이션이 동작할 수 있는 환경을 제공하고, 안정적인 트랜잭션 처리와 관리 다른 기종 시스템과의 애플리케이션 연동을 지원하는 서버

B-2-1-3-2. 미들웨어 현행 시스템 분석 시 고려사항
 - 성능 측면 : 가용성, 성능
 - 지원 측면 : 기술 지원, 구축 비용

---
## C. 요구사항 확인
---
### C-1. 요구사항
---
C-1-1. 요구사항 개념
 - 요구공학은 사용자의 요구가 반영된 시스템을 개발하기 위하여 사용자 요구사항에 대한 도출, 분석, 명세, 호가인 및 검증하는 구조화된 활동

C-1-1-1. 요구공학의 목적
 - 이해관계자 사이에 효과적인 의사소통 수단을 제동하고 시스템 개발의 요구사항에 대한 공통된 이해를 설정
 - 요구사항 누락 방지 및 이해 오류로 인한 불필요한 비용을 절감하고 요구사항 변경 추적을 가능
 - 초기 요구사항 관리로 개발 비용과 시간을 절약하고 효과적인 의사소통 수단을 제공

C-1-1-2. 요구사항 분류
C-1-1-2-1. 기능적 요구사항
 - 시스템이 제공하는 기능
 - 도출방법
 -- 특정 입력에 대해 시스템이 어떻게 반응해야 하는지에 대한 기술
 - 특성
 -- 기능성, 완전성, 일관성

C-1-1-2-2. 비기능적 요구사항
 - 시스템이 수행하는 기능 이외의 사항, 시스템 구축에 대한 제약사항에 관환 요구사항
 - 도출방법
 -- 품질 속성에 관련하여 시스템이 갖춰야할 사항에 관한 기술
 - 특성
 -- 신뢰성, 사용성, 효율성, 유지보수성, 이식성, 보안성 및 품질 관련 요구사항, 제약사항

C-1-2. 요구사항 프로세스

![요구사항 프로세스](https://t1.daumcdn.net/cfile/tistory/99AD5B4B5BEA17BD36)

C-1-2-1. 요구사항 도출 단계 주요 기법
 - 인터뷰
 - 브레인스토밍
 - 델파이 기법 : 전문가의 경험적 지식을 통한 문제 해결 및 미래예측을 위한 방법
 - 롤 플레잉 : 현실에 일어나는 장면을 설정하고 여러 사람이 각자가 맡은 역을 연기함으로써 요구사항을 분석하고 수집하는 방법
 - 워크숍 : 단기간의 집중적인 노력을 통해 다양하고 전문적인 정보를 획득하고 공유하는 방법
 - 설문조사

C-1-2-2. 요구사항 분석 단계 절차
 - 요구사항 분류 -> 개념 모델링 생성 및 분석 -> 할당 -> 협상 -> 정형 분석
 - 정형 분석 : 형식적으로 정의된 의미를 지닌 언어로 요구사항을 표현하는 활동

C-1-2-3. 요구사항 명세 단계 주요 기법
 - 비정형 명세 기법 : 사용자의 요구를 표현할 때 자연어를 기반으로 서술하는 기법
 - 정형 명세 기법 : 사용자의 요구를 표현할 때 수학적인 원리와 표기법을 서술하는 기법

C-1-2-3-1. 요구사항 명세 원리 및 검증 항목
 - 명확성 : 각각의 요구사항 명세 내용은 하나의 의미만 부여해야 함
 - 완전성 : 기능, 성능, 속성, 인터페이스, 설계 제약 등에 관한 모든 시스템 요구사항이 포함되어야 함
 - 검증 가능성 : 요구사항 내용의 충족 여부와 달성 정도에 대한 확인이 가능해야 함
 - 일관성 : 요구사항의 내용 간 상호 모순이 없어야 함
 - 수정 용이성 : 요구사항 변경 시 쉽게 수정 가능해야 함
 - 추적 가능성 : 각 요구사항 근거에 대한 추적과 상호참조가 가능해야 함
 - 개발 후 이용성 : 운영 및 유지보수에 효과적인 이용이 가능해야 함

C-1-2-4. 요구사항 검증 절차
 - 요구사항 목록 확인 -> 요구사항 정의서 작성 여부 확인 -> 비기능적 요구사항의 확인 -> 타 시스템 연계 및 인터페이스 요구사항 확인

C-1-2-4-1. 요구사항 검증 단계의 주요 기법
 - 요구사항 검토
 - 정형 기술 검토 활용
 -- 동료 검토 : 2~3명이 진행하는 리뷰의 형태
 -- 워크 스루 : 검토 자료를 회의 전에 배포해서 사전검토한 후 짧은 시간 동안 회의를 진행하는 형태
 -- 인스펙션 : 소프트웨어 요구, 설계, 원시 코드 등의 저작자 외의 다른 전문가 또는 팀이 검사하여 오류를 찾아내는 공식적 검토 방법
 - 프로토타이필 활용
 - 모델 검증 : 분석 단계에서 개발된 모델의 품질 검증 필요
 - 테스트 케이스 및 테스트를 통한 확인 : 요구사항의 중요한 속성은 최종 제품이 요구사항을 만족시키는지 확인 가능해야 함
 - CASE 도구 활용 검증 : 구조화된 요구사항 명세서에 대해서는 자동화된 일관성 분석을 제공하는 CASE 도구 활용 가능
 - 베이스라인을 통한 검증 : 요구사항 변경을 체계적으로 추적하고 통제하는 시점인 베이스라인을 통한 요구사항에 대한 지속적 검증 수행
 - 요구사항 추적표를 통한 검증 : 요구사항 정의서를 기준으로 개발단계별 최종 산출물이 어떻게 반영되고, 변경되었는지 확인이 가능한 문서

---
## D. 분석 모델 확인하기
---
### D-1. 분석 모델 검증
---
D-1-1. 검증 방법
 - 유스케이스 모델 검증 : 시스템 기능에 대한 유스케이스 모형 상세화 수준 및 적정성 검증을 위해서 액터, 유스케이스, 유스켕스 명세서 점검
 - 개념 수준의 분석 클래스 검증 : 주요 클래스 도출 여부, 도출된 클래스 이름과 속성의 적절성, 올바른 클래스들 간의 관계 여부 점검
 - 분석 클래스 검증 : 경계와 제어 클래스의 도출 여부 및 상세화 정도 확인

D-1-2. 검증 프로세스
 - 검토의견 컬럼 추가 : 분석 모델까지 요구사항 추적표를 작성하고 검토의견 컬럼 추가
 - 검토의견 작성 : 요구사항 목록을 참조하여 요구사항 ID와 요구사항명 입력
 - 검토의견 정제 : 요구사항 추적표에서 요구사항에 대한 검토의견 정제

---
### D-2. 분석 모델의 시스템화 타당성 분석
---
D-2-1. 분석 모델의 기술적 타당성 검토
 - 성능 및 용량 산정의 적정성 : 요구사항을 만족시키기 위한 분석 모델에 따라 시스템을 구현할 때 요구되는 시스템의 자원 식별
 - 시스템 간 상호 운용성 : 분석 모델에서 정의한 구체적인 정보의 존재 여부, 생성 가능성, 교환 방식 지원 등에 대해서 확인
 - IT 시장 성숙도 및 트렌드 부합성 : 분석 모델이 과거의 문제를 해결하고 최근 많이 사용되는 트렌드에 부합되는지 확인
 - 기술적 위험 분석 : 분석 모델이 검증되지 않은 기술의 사용을 가정으로 하고 있어 추가적인 비용 발생 가능성이 있는지 확인

D-2-2. 분석 모델의 시스템화 타당성 분석 프로세스
 - 타당성 검토의견 컬럼 추가 : 분석 모델까지 요구사항 추적표를 작성하고 타당성 검토의견 컬럼을 추가
 - 타당성 검토의견 작성 : 타당성 검토의견을 제외한 나머지 속성들은 분석 모델 검증 수행 내용의 작성 절차와 동일
 - 타당성 분석 결과 검증 : 타당성 분석 결과를 관련 이해관계자에게 배포하여 사전 검토를 요청
 - 타당성 분석 결과 확인 및 배포/공유 : 이해관계자 검증을 거친 타당성 분석 결과를 의사 결정자 확인 / 확정된 타당성 분석 결과를 이해관계자에게 배포하여 공유
